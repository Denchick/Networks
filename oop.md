- Абстракции – основа для построения полиморфного кода
- Интерфейсы – способ описания абстракций
- Наследование – механизм повторного использования кода и способ создания устойчивых поведенческих и структурных отношений между классами
- Полиморфизм – механизм работы с объектами через абстракции, позволяющий создавать модульный расширяемый код
- Абстрактные классы – способ частичной фиксации модели поведения
- Делегирование – способ реализации изменчивой модели поведения

# Инкапсуляция

> **Инкапсуляция** = сокрытие данных и деталей реализации

> **Объект** = контейнер данных (структура) с набором операций (методов) для манипулирования данными

Основное преимущество от инкапсуляции – более аккуратная структура
кода и меньшее количество внутренних взаимосвязей в программе. 

*Часто применение инкапсуляции может привести к ускорению программы. За счет чего?*

**Ответ**: за счет возможности контролировать и прогнозировать состояние объектов. 

1. Можно убрать ненужные проверки на корректность данных (классы за счет инкапсуляции данных позволяют гарантировать корректность состояния объектов);


2. Можно исключить ненужные копирования данных (класс за счет инкапсуляции может контролировать доступ к данным, что позволяет использовать данные большого объема совместно в нескольких объектах).

## Шаблон «Неизменный объект»

Строки в Java построены с использованием шаблона **«неизменный объект»** (Immutable object).

Суть этого шаблона в том, что объект, построенный по этому шаблону, не содержит методов, позволяющих изменить его состояние (а прямое изменение членов объекта невозможно в силу применения инкапсуляции).

Получается, что объект, будучи созданным, в дальнейшем не может быть изменен. 

**Преимущества подхода**:

1. При передаче неизменного объекта как параметра в подпрограмму нет необходимости создавать его копию, чтобы предотвратить объект от возможных его модификаций в подпрограмме. 
2. Если неизменный объект хранит данные в каких-то внутренних структурах (например буфер в классе String), то эти внутренние структуры можно разделять между  несколькими экземплярами объектов класса (например, при взятии подстроки объекты класса String могут совместно использовать один буфер). 

**Классы Java, реализованные по шаблону «Неизменный класс»**

- Контейнеры для примитивных типов данных (Integer, Long, Short, Byte, Character, Boolean, Float, Double)
- Классы, реализующие арифметику неограниченной точности (BigInteger и BigDecimal)

# Константы в Java. Ключевое слово final

Константы в Java реализуются как члены класса с модификаторами `static` и `final`.

- Модификатор `static` позволяет использовать константу без создания экземпляра класса.
- Модификатор `final` запрещает изменение значения члена класса (то есть, собственно, и формирует константу).

```java
public class ConstTest
{
	public static final double PI = 3.14159265358979323846;
	public static void main(String [] args)
	{
		System.out.println(ConstTest.PI);
	}
}
```

# Константы в C#. Ключевые слова readonly и const

Константы в C# реализуются как члены класса с модификатором `const` (**для примитивных типов**) или комбинацией модификаторов `static` и `readonly` (**для ссылочных объектных типов**).

- Модификатор `static` позволяет использовать константу без создания экземпляра класса.
- Модификатор `readonly` запрещает изменение значения члена класса (то есть, собственно, и формирует константу). 
- Модификатор `const` по сути формирует макроподстановку (константа подставляется во все точки использования).

```C#
public class ConstTest
{
	public const double PI = 3.14159265358979323846;
	public static readonly MESSAGE = "Value of Pi is: ";
	public static int Main(String [] args)
	{
		Console.Out.WriteLine(ConstTest.Message + ConstTest.PI);
	}
}
```

# Пакеты в Java

Полное имя каждого класса в Java состоит из двух частей:

<u>Java.lang</u>.<u>String</u>

java.lang - пакет, String - название класса.

Язык Java требует уникальности полного имени класса. Это требование обусловлено тем, как JVM ищет байт-код класса, который нужно загрузить в память. При загрузке класса производятся следующие шаги:

- Специальному модулю (ClassLoader) дается команда на поиск и загрузку байт кода класса с заданным полным именем (наблюдение: если имя класса не является уникальным, то операция некорректна)
- Загруженный байт-код проверяется на целостность и корректность
- Загруженный байт-код по возможности компилируется в машинный код для ускорения работы
- Названный алгоритм повторяется для всех классов, на которые есть ссылки из загруженного класса

Принадлежность класса пакету определяется ключевым словом `package`.

# Интерфейсы и абстракции

Чтобы защитить код от изменчивости условий его использования, его нужно писать так, чтобы он по возможности работал с абстракциями, а не с конкретикой.

> Интерфейс определяет контракт (функциональность), который должен выполняться любой реализацией этого интерфейса.

Суть абстракции не в том, как она устроена внутри, а в том, что она умеет делать. То есть важны не детали реализации, а доступный набор операций (методов).

Таким образом, **классы – это способ создания конкретных реализаций абстракций.** 

### Пример интерфейсов в Java

```java
public interface ByteReader
{
	byte readByte();
	boolean hasMoreData();
}

public interface ByteWriter
{
	void writeByte(byte value);
	void flush();
}
```

### Реализация

``` java
public class FileByteReader implements ByteReader
{
	byte readByte()
	{ 
		код метода
	}
	boolean hasMoreData()
	{
		код метода 
	}
}
```

# Полиморфизм

**Первое правило совместимости по присваиванию в ООП (правило согласованности интерфейсов)**

Пусть `TypeA` – какой-то класс или интерфейс, а `InterfaceB` – какой-то интерфейс. Тогда присваивание значения переменной `varB` в коде:

```
TypeA varA = …;
InterfaceB varB = varA;
```

является корректным в том и только в том случае, когда `TypeA` реализует интерфейс `InterfaceB`.

>  Возможность взаимодействовать с объектом через реализуемый им интерфейс без привязки к специфике объекта называется **полиморфизмом. **

Интерфейсы позволяют отделить функциональные модули программы, скрыть детали реализации. В то же время в чистом виде использование интерфейсов может приводить к **дублированию кода**. 

Проблему тиражирования кода при реализации некоторого интерфейса позволяют решить применение механизма наследования классов и использование абстрактных классов. 

```java
class Parent
{
	private int m_value;
	public Parent(int iValue)
	{ m_value = iValue; }
	protected int getSquare()
	{ return m_value * m_value; }
}

class Child extends Parent
{
	private int m_valueB;
	public Child(int A, int B)
	{
		super(A);
		m_valueB = B;
	}

	public void print()
	{ System.out.println("A^2 = " + getSquare() + " B = " + m_valueB); }
}
```

*Класс потомок наследует все члены и все методы суперкласса. Значит ли это, что подкласс может напрямую работать с любыми членами и с любыми методами суперкласса?*

**Ответ**: нет, не значит. Все зависит от модификаторов доступа.

- `public` – разрешает доступ к члену/методу из любой точки программы
- `private` – разрешает доступ к члену/методу только из того класса, в котором член/метод объявлен
- `protected` – разрешает доступ к члену/методу из того класса, в котором член/метод объявлен, из любого его подкласса и из любого класса того же пакета, в котором класс объявлен
- **Отсутствие модификатора доступа** означает так называемый доступ в пределах пакета (package – доступ). В этом случае доступ к члену/методу разрешается из того класса, в котором член/метод объявлен и из любого класса того же пакета, в котором класс объявлен.

**Наблюдение**: принцип инкапсуляции остается справедлив и в случае механизма наследования. Внутреннюю структуру класса следует защищать и от подклассов. Поэтому обычно следует поступать так:

- все члены класса изначально снабжать модификатором `private`
- в случае необходимости доступа к члену класса из подкласса уровень
  доступа можно повысить до *protected*, но более предпочтительным
  является использование методов для доступа к членам класса. 

# Абстрактный класс

Наличие виртуальных методов позволяет вводить конструкцию, занимающую промежуточное положение между интерфейсами и настоящими классами. Эта конструкция называется *абстрактный класс*. 

```java
abstract class Parent
{
	public void printMessage()
	{ System.out.println(getMessage()); }
	
	abstract protected String getMessage();
}

class Child extends Parent
{
	protected String getMessage()
	{ return "It is a child class!"; }
}

Parent parent = new Parent(); // недопустимо

Child child = new Child();
child.printMessage(); // печатает "It is a child class!"

Parent something = new Child(); // корректное присваивание
something.printMessage(); // печатает "It is a child class!" 
```

# Использование наследования

Важно понимать, что с точки зрения семантики, класс предок является обобщением класса потомка (то есть имеет более простое описание модели поведения, меньше свойств, меньше методов).

Класс потомок является уточнением этой более общей модели за счет расширения этой модели. Он не должен сужать унаследованное множество допустимых состояний за счет наложения ограничений на унаследованные атрибуты и операции.

> Один из принципов ООП (**принцип замены Лисков, LSP**) как раз и требует, чтобы класс потомок можно было бы использовать везде, где можно использовать класс предок. Что и означает, в частности, что множество состояний класса потомка не может быть меньше множества состояний класса предка.

# Иерархия объектов в Java

Все классы в Java выстроены в единую иерархию, в корне которой находится класс Object

![hierarchy](hierarchy.png)

Это позволяет:

- Получить тип, который совместим по присваиванию с любым объектным типом
- Зафиксировать функциональность, присущую ВСЕМ объектам в Java

Например, любой объект можно превратить в строку, вызвав метод `toString()`.

**Проблема**: у одного класса может быть несколько текстовых представлений! Поэтому обычно неочевидно, какое из представлений следует сопоставить методу `toString()`.

**Вывод**: метод `toString()` нежелательно использовать для реализации операции
преобразования объекта в строку в неотладочных целях, поскольку:

1. Не всегда очевиден формат, в котором будет выводиться информация
2. Высок риск, что другой программист изменит формат на более удобный для отладки, тем самым разрушив логику других компонентов системы, опирающихся на знание формата результата метода `toString()`.
3. Сложно отслеживать полиморфные цепочки вызовов, поскольку этот метод присутствует во всех классах Java.

Делать надо так:

```java
//для бизнес-логики
public String toStringValue()
{
	return <строковое представление>;
}

// для отладочной печати
public String toString()
{
	return toStringValue();
}
```

# Методы класса Object. equals и getHashCode.

- `public int hashCode()` - должен просто вернуть некоторое целое число, согласованное с состоянием объекта.
- `public boolean equals(Object obj)` - совпадает ли состояние двух разных
  объектов.
- `protected Object clone() ` - создает точную копию объекта.
- `protected void finalize()` - Финализатор. Вызывается Java-машиной в тот момент, когда объект уничтожается. **Не путать с деструктором!**
- `public Class getClass()` - Позволяет программно узнать структуру класса, к которому относится данный объект.
- `public void notify()`, `public void notifyAll()`, `public void wait()` - Служат для реализации межпоточной синхронизации при программировании многопоточных приложений. 

### Подробности

- У класса Object метод equals реализован так:

```java
public boolean equals(Object obj)
{
	return (this == obj);
}
```

- Единственное формальное требование для equals() и getHashCode(): если `a.equals(b)` возвращает true, то `a.hashCode()` и `b.hashCode()` обязаны совпадать. 

  **Наблюдение**: Из неравенства хэш-кодов следует неравенство объектов. Но из равенства хэш-кодов не следует равенство объектов (возможных состояний объекта обычно гораздо больше чем возможных хэш-кодов).

  Наличие метода `hashCode()` позволяет:

1. Повысить эффективность поиска объекта среди множества объектов;
2. Эффективно хранить любые объекты Java в хэш-таблицах. 

- При помощи операции = невозможно создать копию объекта, поскольку реально создается лишь новая ссылка на уже существующий объект. Метод `clone()` позволяет создавать точную копию объекта.

```java
public class ValueHolder implements Cloneable
{
	.....
	public Object clone()
  	{
  		try
  		{
  			return super.clone();
  		}
  		catch (CloneNotSupportedException e)
  		{
  			return null;
  		}
  	}
  	......
}
```

# Делегирование

*Когда наследование не работает…*

Кароч, там только примеры, вроде все понятно: наследование - плохо, делигирование - хорошо. Читай статью [Наследование или делигирование](http://irbis-school.com/blog/full/34).

# Обработка ошибок в Java

В Java введен механизм принудительного контроля за ошибками. Цель введения механизма принудительного контроля за ошибками в том, чтобы обязать программиста:

1. Декларировать в сигнатуре метода, какие ошибки могут возникать в
  конкретном методе;
2. Требовать явной реакции (специальной обработки) в тех точках кода,
  где могут возникать ошибки. 

Исключения в Java являются классами и образуют такую иерархию:

![hierarchy2](C:\Users\Volkov\Desktop\hierarchy2.png)

```java
public static void process(String [] args) throws NotImplementedException
{
	throw new NotImplementedException("Реализуй метод падла");
}
```

Исключения, для которых Java проверяет обязательное наличие обработчика называются **контролируемыми**. К ним относятся все подклассы класса `Exception`, кроме класса `RuntimeException` и его подклассов.

Исключения, которые могут возникать практически в каждой строке (`ArithmeticException`, `NullPointerException`, `ArrayIndexOutOfBoundsException` и подобные) выделены в особую группу (подклассы класса `RuntimeException`), для которой не проводится принудительная проверка наличия обработчика. Такие исключения называются **неконтролируемыми**.

Исключения, которые возникают в результате внутренних проблем во время работы JVM, выделены в отдельную группу **ошибок Java машины** (подклассы класса `Error`). Программист может обработать такие ошибки, но в большинстве случаев этого делать не приходится.

# Исключения в C#

1. Модель работы идентична используемой в Java.
2. Проброс исключений в C# работает в разы медленней!
3. Есть предопределенная иерархия исключений (более бедная, чем в Java)
4. Нет контролируемых исключений
5. Ловушка для исключения выбирается так же, как и в Java, то есть путем сопоставления классов по иерархии наследования
6. Для перехвата всех исключений можно использовать блок catch без указания типа перехватываемой ошибки (будет подразумеваться тип `Exception`)
7. По причине низкой эффективности исключений и отсутствия контролируемых исключений в C# ошибочное состояние часто возвращают через результат подпрограммы, а не через проброс исключения.